<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrabble Trainer</title>
    <!-- Load React and ReactDOM from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Load Babel to transform JSX/ES6 into browser-compatible JavaScript -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font import for aesthetics */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .spinner { border-top-color: #f87171; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-950">

    <div id="root">
        <!-- The React app will be rendered here -->
    </div>

    <!-- CRITICAL: type="text/babel" tells the browser to use the Babel library to process this script block -->
    <script type="text/babel">

        // FIX: React hooks are accessed globally in this environment.
        const { useState, useEffect, useCallback, useMemo } = React;

        // Note: lucide-react icons are mapped to their function components here since imports are tricky with Babel CDN
        const Settings = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.78 1.46a2 2 0 0 0 .73 2.73l.15.08a2 2 0 0 1 1 1.73v.52a2 2 0 0 1-1 1.73l-.15.08a2 2 0 0 0-.73 2.73l.78 1.46a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.78-1.46a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.73v-.52a2 2 0 0 1 1-1.73l.15-.08a2 2 0 0 0 .73-2.73l-.78-1.46a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-1 1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>;
        const Loader = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>;
        const CheckCircle = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.6-8.23"/><path d="M9 11l3 3L22 4"/></svg>;
        const XCircle = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M15 9L9 15"/><path d="M9 9l6 6"/></svg>;
        const UploadCloud = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.52 8.237"/><path d="M12 12l-4 4"/><path d="M12 12l4 4"/><path d="M12 12v9"/></svg>;
        const Link = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>;


        // --- CONFIGURATION AND DICTIONARY ---

        // IMPORTANT: Replace these with the RAW URLs of your hosted .txt files on GitHub.
        const EXTERNAL_URL_MAP = {
            'EXTERNAL_2': "https://raw.githubusercontent.com/kaishx/scrabbletrainer/refs/heads/main/2_letter_words.txt",
            'EXTERNAL_3': "https://raw.githubusercontent.com/kaishx/scrabbletrainer/refs/heads/main/3_letter_words.txt",
            'EXTERNAL_4': "https://raw.githubusercontent.com/kaishx/scrabbletrainer/refs/heads/main/4_letter_words.txt",
            'EXTERNAL_5': "https://raw.githubusercontent.com/kaishx/scrabbletrainer/refs/heads/main/5_letter_words.txt",
            'EXTERNAL_6': "https://raw.githubusercontent.com/kaishx/scrabbletrainer/refs/heads/main/6_letter_words.txt",
            'EXTERNAL_7': "https://raw.githubusercontent.com/kaishx/scrabbletrainer/refs/heads/main/7_letter_words.txt",
            'EXTERNAL_8': "https://raw.githubusercontent.com/kaishx/scrabbletrainer/refs/heads/main/8_letter_words.txt",
        };

        const WORD_LENGTH_OPTIONS = [
            { label: "2 Letters", min: 2, max: 2, source: 'EXTERNAL_2' },
            { label: "3 Letters", min: 3, max: 3, source: 'EXTERNAL_3' },
            { label: "4 Letters", min: 4, max: 4, source: 'EXTERNAL_4' },
            { label: "5 Letters", min: 5, max: 5, source: 'EXTERNAL_5' },
            { label: "6 Letters", min: 6, max: 6, source: 'EXTERNAL_6' },
            { label: "7 Letters", min: 7, max: 7, source: 'EXTERNAL_7' },
            { label: "8 Letters", min: 8, max: 8, source: 'EXTERNAL_8' },
            { label: "Custom .txt", min: 0, max: 0, source: 'UPLOAD' },
        ];

        // --- UTILITY FUNCTIONS (AI CALLS) ---

        const safeJsonParse = (text) => {
            try {
                const cleanedText = text.replace(/```json|```/g, '').trim();
                const parsed = JSON.parse(cleanedText);
                if (Array.isArray(parsed) && parsed.every(item => typeof item === 'string')) {
                    return parsed.map(w => w.trim().toUpperCase());
                }
            } catch (e) {
                console.error("Failed to parse AI response as JSON array:", e);
                return [];
            }
            return [];
        }

        // Generic API caller with backoff and JSON parsing
        const callGeminiApi = async (systemPrompt, userQuery) => {
            // Using the user-provided API key from their original file.
            const apiKey = "AIzaSyCz5cGG0vOw2uARCYd94cQvCQ6io7I75R4"; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "ARRAY",
                        items: { type: "STRING" },
                    }
                },
            };

            let attempt = 0;
            const maxRetries = 3;

            while (attempt < maxRetries) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        if (response.status === 429 && attempt < maxRetries - 1) {
                            const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            attempt++;
                            continue;
                        }
                        throw new Error(`API call failed with status: ${response.status}`);
                    }

                    const result = await response.json();
                    const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (text) {
                        const generatedWords = safeJsonParse(text);
                        return generatedWords;
                    }
                    throw new Error("AI response was empty or malformed.");

                } catch (error) {
                    console.error("Gemini API Request Error:", error);
                    if (attempt < maxRetries - 1) {
                         const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                         await new Promise(resolve => setTimeout(resolve, delay));
                         attempt++;
                         continue;
                    }
                    return [];
                }
            }
            return [];
        };

        /**
         * Generates and validates Fake (Nonsense) words against the realWordSet.
         * The loop ensures we get the required number of words that DO NOT exist in your list.
         * @param {number} length - Required word length.
         * @param {number} count - Number of words to generate.
         * @param {Set<string>} realWordSet - The Set of all real, validated words (uppercase).
         */
        const generateFakeWords = async (length, count, realWordSet) => {
            let required = count;
            let foundFakes = [];
            let attempts = 0;
            const maxAttempts = 5; // Allow more attempts to compensate for AI generating real words

            while (foundFakes.length < required && attempts < maxAttempts) {
                // Request 2x the remaining amount for efficiency
                const batchSize = Math.max(required - foundFakes.length, required) * (attempts + 1);
                
                // Keep the prompt simple, relying on client-side validation
                const systemPrompt = `You are a creative linguist. Your task is to generate exactly ${batchSize} entirely fake, yet phonetically plausible, English words that are exactly ${length} letters long. Provide the response as a JSON array of strings, ONLY the words, no descriptions or extra text.`;
                const userQuery = `Generate ${batchSize} fake words of exactly ${length} letters.`;

                const newWords = await callGeminiApi(systemPrompt, userQuery);
                
                // --- CORE VALIDATION LOGIC (Concise Check) ---
                const validatedWords = newWords.filter(word => !realWordSet.has(word));
                // ---------------------------------------------
                
                foundFakes.push(...validatedWords);
                attempts++;
                if (validatedWords.length === 0 && attempts < maxAttempts) {
                     console.log("AI generated only real words. Retrying...");
                     await new Promise(r => setTimeout(r, 1500));
                }
            }
            
            // Return only the required amount
            return foundFakes.slice(0, count);
        };


        // --- MAIN REACT COMPONENT ---

        const App = () => {
            // State for app flow
            const [status, setStatus] = useState('SETUP');

            // State for configuration
            const [wordCount, setWordCount] = useState(20);
            const [selectedLengthIndex, setSelectedLengthIndex] = useState(3); // Default to 5-letter external

            // State for fetching/loading/errors
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);

            // State for the uploaded dictionary file content (for 'UPLOAD' source)
            const [uploadedDictionary, setUploadedDictionary] = useState(null);

            // Game state
            const [currentWordIndex, setCurrentWordIndex] = useState(0);
            const [trainingList, setTrainingList] = useState([]);

            // Derived values
            const wordConfig = WORD_LENGTH_OPTIONS[selectedLengthIndex];
            const wordsToPick = Math.floor(wordCount / 2);
            const currentWord = trainingList[currentWordIndex];
            const isCustomUploadSelected = wordConfig.source === 'UPLOAD';

            const resetGame = () => {
                setStatus('SETUP');
                setTrainingList([]);
                setCurrentWordIndex(0);
                setError(null);
            };

            // --- DICTIONARY HANDLING FUNCTIONS ---

            // Generic fetch from external URL map
            const fetchExternalDictionary = async (sourceKey, requiredLength) => {
                const url = EXTERNAL_URL_MAP[sourceKey];

                if (url.includes("example.com")) {
                    throw new Error(`URL for ${requiredLength} letters is a placeholder. Please update EXTERNAL_URL_MAP.`);
                }

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}. Check your GitHub Raw Content URL.`);
                }
                const text = await response.text();

                const words = text.split(/\s+/)
                                        .map(w => w.trim().toUpperCase())
                                        .filter(w => w.length >= requiredLength && w.length <= 15 && /^[A-Z]+$/.test(w)); 
                                        // Added simple regex filter for letters only
                
                if (words.length === 0) {
                    throw new Error(`No usable words found in the external file for length ${requiredLength}.`);
                }
                return words;
            };

            // Handler for local file upload (Source: UPLOAD)
            const handleFileUpload = (event) => {
                setUploadedDictionary(null);
                setError(null);
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const text = e.target.result;
                        
                        // Use the same robust splitting logic for uploaded files
                        const words = text.split(/\s+/)
                                                .map(w => w.trim().toUpperCase())
                                                .filter(w => w.length > 0 && /^[A-Z]+$/.test(w));

                        if (words.length < wordsToPick) {
                            setError(`Uploaded file contains only ${words.length} usable words, which is not enough to create ${wordsToPick} real words.`);
                            return;
                        }

                        // Calculate length metrics for generating plausible fake words later
                        const lengths = words.map(w => w.length);
                        const minLength = Math.min(...lengths);
                        const maxLength = Math.max(...lengths);
                        const meanLength = Math.round(lengths.reduce((a, b) => a + b, 0) / lengths.length);

                        setUploadedDictionary({
                            words,
                            minLength,
                            maxLength,
                            meanLength, // Store mean length for generating fakes
                            fileName: file.name
                        });
                        setError(null);

                    } catch (error) {
                        setError("Error processing file: " + error.message);
                    }
                };
                reader.onerror = () => {
                    setError("Failed to read file.");
                };
                reader.readAsText(file);
            };


            // Main function to generate the session
            const generateTrainingSession = useCallback(async () => {
                setStatus('GENERATING');
                setError(null);
                setIsLoading(true);

                const source = wordConfig.source;
                const requiredLength = wordConfig.min;
                let realWords = [];
                let fullWordList = [];
                let requiredLengthForFakes = requiredLength; 
                
                try {
                    // --- STEP 1: Get Full List and Real Words for Training ---
                    if (source.startsWith('EXTERNAL')) {
                        fullWordList = await fetchExternalDictionary(source, requiredLength);

                        // Create the Set for validation, containing only words of the required length
                        const realWordSet = new Set(fullWordList.filter(w => w.length === requiredLength));
                        const filteredList = [...realWordSet];

                        if (filteredList.length < wordsToPick) {
                            throw new Error(`External list only contains ${filteredList.length} words of length ${requiredLength}, but ${wordsToPick} are required.`);
                        }

                        // Randomly select words for the training session
                        const shuffledDict = filteredList.sort(() => 0.5 - Math.random());
                        realWords = shuffledDict.slice(0, wordsToPick);

                        // This set is also the validation set
                        requiredLengthForFakes = requiredLength;
                        
                    } else if (source === 'UPLOAD') {
                        if (!uploadedDictionary) {
                            throw new Error("Please upload a custom word file first.");
                        }
                        fullWordList = uploadedDictionary.words;
                        // For UPLOAD, the validation set contains ALL words uploaded (all lengths)
                        const realWordSet = new Set(fullWordList); 
                        
                        requiredLengthForFakes = uploadedDictionary.meanLength; // Use mean length for generating plausible fakes
                        
                        // Randomly select N words from the uploaded list (any length)
                        const shuffledDict = [...realWordSet].sort(() => 0.5 - Math.random());
                        realWords = shuffledDict.slice(0, wordsToPick);

                        if (realWords.length < wordsToPick) {
                            throw new Error(`Could only extract ${realWords.length} real words from the uploaded list, need ${wordsToPick}.`);
                        }
                    } else {
                        throw new Error("Invalid word source selected.");
                    }

                    // *** CRITICAL STEP: Create the validation set after loading the source ***
                    const validationSet = new Set(fullWordList);


                    // --- STEP 2: Get Fake Words from AI (now includes validation) ---
                    const fakeWords = await generateFakeWords(
                        requiredLengthForFakes, 
                        wordsToPick, 
                        validationSet
                    );

                    if (fakeWords.length < wordsToPick) {
                        throw new Error(`Failed to generate ${wordsToPick} unique 'Fake' words that didn't already exist in your list.`);
                    }

                    // --- STEP 3: Combine and Shuffle ---
                    const finalCount = Math.min(realWords.length, fakeWords.length);
                    const finalRealWords = realWords.slice(0, finalCount);
                    const finalFakeWords = fakeWords.slice(0, finalCount);

                    let combinedList = [
                        ...finalRealWords.map(word => ({
                            word,
                            isReal: true,
                            correct: null,
                            userGuess: null,
                            source: source === 'UPLOAD' ? 'UPLOAD' : 'EXTERNAL'
                        })),
                        ...finalFakeWords.map(word => ({
                            word,
                            isReal: false,
                            correct: null,
                            userGuess: null,
                            source: 'AI'
                        })),
                    ];

                    // Randomly shuffle the order
                    for (let i = combinedList.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [combinedList[i], combinedList[j]] = [combinedList[j], combinedList[i]];
                    }

                    setWordCount(combinedList.length);
                    setTrainingList(combinedList);
                    setCurrentWordIndex(0);
                    setStatus('PLAYING');

                } catch (e) {
                    setError(e.message);
                    setStatus('SETUP');
                } finally {
                    setIsLoading(false);
                }
            }, [wordConfig, wordsToPick, uploadedDictionary]);


            // Step 6: Player input and scoring
            const handleGuess = useCallback((guessIsReal) => {
                if (status !== 'PLAYING') return;

                const isCorrect = currentWord.isReal === guessIsReal;

                const updatedList = trainingList.map((item, index) =>
                    index === currentWordIndex
                        ? { ...item, userGuess: guessIsReal, correct: isCorrect }
                        : item
                );
                setTrainingList(updatedList);

                // Check if game is over
                if (currentWordIndex < updatedList.length - 1) {
                    setCurrentWordIndex(prev => prev + 1);
                } else {
                    setStatus('REPORT'); // End of game
                }
            }, [status, currentWord, trainingList, currentWordIndex]);

            // Keyboard controls for [ and ]
            useEffect(() => {
                const handleKeyDown = (event) => {
                    if (status === 'PLAYING') {
                        if (event.key === '[') {
                            handleGuess(true); // Real
                        } else if (event.key === ']') {
                            handleGuess(false); // Fake
                        }
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [status, handleGuess]);

            // Memoize results for the report screen
            const results = useMemo(() => {
                if (status !== 'REPORT' || trainingList.length === 0) return null;

                const total = trainingList.length;
                const correct = trainingList.filter(item => item.correct).length;
                const accuracy = total > 0 ? (correct / total * 100).toFixed(1) : 0;

                // Detailed breakdown
                const allWords = trainingList.map((item, index) => ({
                    id: index,
                    word: item.word,
                    type: item.isReal ? `Real (${item.source})` : 'Fake (AI)',
                    isCorrect: item.correct,
                    userGuess: item.userGuess,
                    correctAnswer: item.isReal ? 'Real' : 'Fake'
                }));

                const wrongWords = allWords.filter(item => !item.isCorrect);

                return {
                    total,
                    correct,
                    accuracy,
                    wrongWords
                };
            }, [status, trainingList]);


            // --- UI COMPONENTS ---

            const Header = ({ title }) => (
                <div className="text-center mb-10">
                    <h1 className="text-4xl sm:text-5xl font-extrabold text-red-500 mb-2">{title}</h1>
                    <p className="text-gray-400 text-lg">Test your lexicon against the odds.</p>
                </div>
            );

            const SetupScreen = () => (
                <div className="space-y-6 max-w-lg mx-auto p-6 bg-gray-800 rounded-xl shadow-2xl border border-gray-700">
                    <h2 className="text-2xl font-semibold text-red-400 border-b border-gray-700 pb-3 flex items-center">
                        <Settings className="w-6 h-6 mr-2"/> Training Settings
                    </h2>

                    {/* Word Count */}
                    <div>
                        <label htmlFor="wordCount" className="block text-sm font-medium text-gray-300 mb-1">Total Words (Real + Fake)</label>
                        <input
                            id="wordCount"
                            type="range"
                            min="10"
                            max="50"
                            step="2"
                            value={wordCount}
                            onChange={(e) => setWordCount(parseInt(e.target.value))}
                            className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg accent-red-500"
                        />
                        <p className="text-sm text-gray-400 mt-1">Total: <span className="font-bold text-red-300">{wordCount}</span> (Generating {wordsToPick} Real & {wordsToPick} Fake words)</p>
                    </div>

                    {/* Word Length */}
                    <div>
                        <label htmlFor="wordLength" className="block text-sm font-medium text-gray-300 mb-1">Word Length / Source</label>
                        <select
                            id="wordLength"
                            value={selectedLengthIndex}
                            onChange={(e) => setSelectedLengthIndex(parseInt(e.target.value))}
                            className="w-full px-4 py-2 bg-gray-700 text-gray-200 border border-gray-600 rounded-lg focus:ring-red-500 focus:border-red-500 transition"
                        >
                            {WORD_LENGTH_OPTIONS.map((option, index) => (
                                <option key={index} value={index}>
                                    {option.label}
                                </option>
                            ))}
                        </select>
                        {wordConfig.source.startsWith('EXTERNAL') && (
                            <p className="text-xs text-gray-500 mt-1 flex items-center"><Link className="w-3 h-3 mr-1"/> Source: {EXTERNAL_URL_MAP[wordConfig.source]}</p>
                        )}
                    </div>

                    {/* File Upload for Custom Source */}
                    {isCustomUploadSelected && (
                        <div className="border border-red-500 border-dashed p-4 rounded-lg bg-gray-900">
                            <label className="block text-sm font-medium text-red-300 mb-2 flex items-center">
                                <UploadCloud className="w-5 h-5 mr-2"/> Upload Custom .txt List
                            </label>
                            <input
                                type="file"
                                accept=".txt"
                                onChange={handleFileUpload}
                                className="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-red-500 file:text-white hover:file:bg-red-600 cursor-pointer"
                            />
                            {uploadedDictionary && (
                                <p className="text-xs text-green-400 mt-2">
                                    Loaded: <span className="font-bold">{uploadedDictionary.fileName}</span> ({uploadedDictionary.words.length} words total).
                                </p>
                            )}
                        </div>
                    )}

                    {/* Error Message */}
                    {error && (
                        <div className="bg-red-900/50 border border-red-700 text-red-300 p-3 rounded-lg text-sm font-medium">
                            {error}
                        </div>
                    )}

                    {/* Start Button */}
                    <button
                        onClick={generateTrainingSession}
                        disabled={isLoading || (isCustomUploadSelected && !uploadedDictionary) || error}
                        className={`w-full py-3 mt-4 text-xl font-bold rounded-lg transition duration-200 ${
                            (isLoading || (isCustomUploadSelected && !uploadedDictionary) || error)
                            ? 'bg-gray-700 text-gray-500 cursor-not-allowed'
                            : 'bg-red-600 hover:bg-red-500 text-white shadow-red-500/50 shadow-lg'
                        } flex items-center justify-center`}
                    >
                        {isLoading ? (
                            <>
                                <Loader className="w-6 h-6 mr-3 spinner"/>
                                Generating Session...
                            </>
                        ) : (
                            'Start Training'
                        )}
                    </button>
                </div>
            );

            const PlayingScreen = () => (
                <div className="text-center">
                    <p className="text-gray-400 text-xl mb-8">
                        Word <span className="font-bold text-red-300">{currentWordIndex + 1}</span> of <span className="font-bold text-red-300">{trainingList.length}</span>
                    </p>
                    
                    <div className="bg-gray-800 inline-block px-12 py-8 sm:px-20 sm:py-16 rounded-3xl shadow-2xl border-4 border-red-500 mb-10 transform hover:scale-[1.02] transition duration-300">
                        <h2 className="text-6xl sm:text-8xl font-black tracking-widest text-white uppercase">
                            {currentWord.word}
                        </h2>
                    </div>

                    <p className="text-gray-500 text-sm mb-6">Press [ for Real or ] for Fake</p>

                    <div className="flex justify-center space-x-6">
                        <button
                            onClick={() => handleGuess(true)}
                            className="w-40 py-4 text-lg font-bold rounded-xl bg-green-600 hover:bg-green-500 text-white shadow-green-500/50 shadow-lg transform active:scale-95 transition duration-150"
                        >
                            Real
                        </button>
                        <button
                            onClick={() => handleGuess(false)}
                            className="w-40 py-4 text-lg font-bold rounded-xl bg-red-600 hover:bg-red-500 text-white shadow-red-500/50 shadow-lg transform active:scale-95 transition duration-150"
                        >
                            Fake
                        </button>
                    </div>
                </div>
            );

            const ReportScreen = () => (
                <div className="max-w-xl mx-auto space-y-8 p-6 bg-gray-800 rounded-xl shadow-2xl border border-gray-700">
                    <h2 className="text-3xl font-bold text-green-400 text-center border-b border-gray-700 pb-4">
                        Training Complete!
                    </h2>
                    
                    <div className="flex justify-between items-center bg-gray-900 p-4 rounded-lg">
                        <p className="text-gray-300 font-medium">Accuracy:</p>
                        <p className={`text-3xl font-extrabold ${results.accuracy >= 75 ? 'text-green-400' : 'text-yellow-400'}`}>
                            {results.accuracy}%
                        </p>
                    </div>
                    
                    <div className="flex justify-around text-center">
                        <div className="p-3">
                            <p className="text-2xl font-bold text-white">{results.correct}</p>
                            <p className="text-sm text-gray-400">Correct</p>
                        </div>
                        <div className="p-3 border-l border-r border-gray-700">
                            <p className="text-2xl font-bold text-white">{results.total - results.correct}</p>
                            <p className="text-sm text-gray-400">Incorrect</p>
                        </div>
                        <div className="p-3">
                            <p className="text-2xl font-bold text-white">{results.total}</p>
                            <p className="text-sm text-gray-400">Total</p>
                        </div>
                    </div>

                    {results.wrongWords.length > 0 && (
                        <div className="mt-6">
                            <h3 className="text-xl font-semibold text-red-400 mb-3 border-b border-gray-700 pb-2">Words to Review ({results.wrongWords.length})</h3>
                            <div className="space-y-3 max-h-80 overflow-y-auto pr-2">
                                {results.wrongWords.map(item => (
                                    <div key={item.id} className="flex justify-between items-center p-3 rounded-lg bg-gray-900 border border-red-800/50">
                                        <span className="font-mono text-lg font-bold text-white">{item.word}</span>
                                        <div className="text-right">
                                            <p className="text-sm text-gray-400">Your Guess: <span className="font-semibold text-red-300">{item.userGuess ? 'Real' : 'Fake'}</span></p>
                                            <p className="text-xs text-red-500">Correct: <span className="font-semibold">{item.correctAnswer}</span> ({item.type})</p>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    <button
                        onClick={resetGame}
                        className="w-full py-3 mt-6 text-lg font-bold rounded-lg bg-red-600 hover:bg-red-500 text-white shadow-red-500/50 shadow-lg transition duration-150"
                    >
                        Restart Training
                    </button>
                </div>
            );


            // --- Main Render ---

            let content;
            let headerTitle;

            switch (status) {
                case 'SETUP':
                case 'GENERATING':
                    content = <SetupScreen />;
                    headerTitle = "Lexi-Sense Trainer";
                    break;
                case 'PLAYING':
                    content = <PlayingScreen />;
                    headerTitle = "Guess: Real or Fake?";
                    break;
                case 'REPORT':
                    content = <ReportScreen />;
                    headerTitle = "Results & Review";
                    break;
                default:
                    content = <SetupScreen />;
                    headerTitle = "Lexi-Sense Trainer";
            }

            return (
                <div className="min-h-screen pt-12 pb-12 flex flex-col items-center justify-start">
                    <Header title={headerTitle} />
                    {content}
                </div>
            );
        };

        // Render the App component into the root element
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
